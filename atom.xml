<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coder.LionlyloveK</title>
  
  <subtitle>一只小小的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-25T07:15:17.341Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Coder.LionlyloveK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js-函数防抖与函数节流</title>
    <link href="http://yoursite.com/2020/03/25/js-%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    <id>http://yoursite.com/2020/03/25/js-%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</id>
    <published>2020-03-25T05:43:42.000Z</published>
    <updated>2020-03-25T07:15:17.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些dom或者bom事件,如<code>resize</code>,<code>scroll</code>,<code>input</code>…会频繁执行(采用最小的时间单位4ms-10ms),浪费性能也容易卡顿,可以用防抖和节流做些性能优化</p></blockquote><h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h2><blockquote><p>显示器刷新率一般是60/120fps,人眼睛能捕捉的频率,如果特别高,没有实际意义</p></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流(固定单位时间内触发一次)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span> <span class="comment">// 做一个判断标识,当是false,return</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//闭包</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">false</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// 改变指针和传入参数</span></span><br><span class="line">      flag = <span class="literal">true</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><blockquote><p>如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流(固定单位时间内触发一次)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>对于函数防抖，有以下几种应用场景：</strong><br>1.给按钮加函数防抖防止表单多次提交。<br>2.对于输入框连续输入进行AJAX验证时，用函数防抖能有效减少请求次数。<br>3.判断<code>scroll</code>是否滑到底部，滚动事件+函数防抖</p><blockquote><p>总的来说，适合多次事件<strong>一次响应</strong>的情况</p></blockquote><p><strong>对于函数节流，有以下几种应用场景：</strong><br>1.游戏中的刷新率。<br>2.DOM元素拖拽。<br>3.Canvas画笔功能</p><blockquote><p>总的来说，适合<strong>大量事件</strong>按时间做<strong>平均</strong>分配触发</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一些dom或者bom事件,如&lt;code&gt;resize&lt;/code&gt;,&lt;code&gt;scroll&lt;/code&gt;,&lt;code&gt;input&lt;/code&gt;…会频繁执行(采用最小的时间单位4ms-10ms),浪费性能也容易卡顿,可以用防抖和节流做些性能优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;函数节流-throttle&quot;&gt;&lt;a href=&quot;#函数节流-throttle&quot; class=&quot;headerlink&quot; title=&quot;函数节流(throttle)&quot;&gt;&lt;/a&gt;函数节流(throttle)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;显示器刷新率一般是60/120fps,人眼睛能捕捉的频率,如果特别高,没有实际意义&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>react学习</title>
    <link href="http://yoursite.com/2020/03/25/react01/"/>
    <id>http://yoursite.com/2020/03/25/react01/</id>
    <published>2020-03-25T00:56:26.648Z</published>
    <updated>2020-03-25T06:05:14.767Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>input</code>里的<code>onchange</code>事件要传<code>event</code>来获取内容</p></blockquote><h3 id="两种绑定this的方法"><a href="#两种绑定this的方法" class="headerlink" title="两种绑定this的方法"></a>两种绑定this的方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">this</span>.事件名.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">&#123;a=&gt;<span class="keyword">this</span>.事件名(a)&#125;</span><br></pre></td></tr></table></figure><p><strong>使用实验性语法绑定可以直接绑定<code>this</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事件名 =<span class="function"><span class="params">()</span> =&gt;</span>&#123; <span class="comment">//直接绑定了this</span></span><br><span class="line">    代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;input&lt;/code&gt;里的&lt;code&gt;onchange&lt;/code&gt;事件要传&lt;code&gt;event&lt;/code&gt;来获取内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;两种绑定this的方法&quot;&gt;&lt;a href=&quot;#两种绑定th
      
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
</feed>
